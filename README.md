# Chương 1. Tổng quan một hệ thống Linux.



> Thiên chúa thấy mọi sự người đã làm, và thấy rằng nó đuợc làm rất tốt. - _Bible King James Version. Genesis 1:31_

Chương này cho chúng ta một cái nhìn tổng quát về một hệ thống Linux. Đầu tiên , các dịch vụ chính đuợc cung cấp bởi hệ điều hành sẽ đuợc miêu tả . Sau đó , các chương trình mà triển khai các dịch vụ đó cũng sẽ đuợc đề cập qua một chút. Mục đích của chương này chỉ là cho chúng ta thấy đuợc toàn cảnh của một hệ thống , những phần chi tiết hơn sẽ đuợc đi sâu ở các mục sau.

### 1.1. Các phần khác nhau của một hệ điều hành

UNIX và các hệ thống UNIX-like ( Linux chẳng hạn) , bao gồm một hạt nhân (kernel) và một vài các _chương trình hệ thống_. Cũng có những chương trình ứng dụng (_application programs_) để giúp người dùng hoàn thành những tác vụ cụ thể như soạn thảo văn bản hoặc theo dõi performance. _Kernel_ chính là **trái tim** của hệ điều hành. Thông thường người ta cho rằng Kernel tự nó đã chính là một hệ điều hành rồi, nhưng không phải vậy. Một hệ điều hành thực sự không chỉ cung chấp cho người dùng một kernel không thôi, mà còn rất nhiều các dịch vụ khác. Hệ điều hành sẽ theo dõi các tệp tin trên đĩa , khởi động các chương trình và chạy chúng một cách đồng thời (**concurrently**) , gán bộ nhớ và các tài nguyên đến các tiến trình(**processes**) khác nhau , nhận và gửi các gói tin từ mạng , và những tác vụ khác nữa. Bản thân Kernel làm rất ít việc, nhưng nó cung cấp các công cụ mà với các công cụ đó, tất cả các services có thể đuợc xây dựng. Bằng cách này Kernel cung cấp sự bảo vệ cho người dùng khỏi những thứ khác , và bắt các services hoạt động theo một khuôn mẫu mà kernel đã đề ra. Các công cụ đuợc cung cấp bởi Kernel đuợc sử dụng thông qua các _Lời gọi hệ thống_ - **System calls** Hệ điều hành sử dụng các công cụ đuợc cung cấp bởi kernel để triển khai các dịch vụ khác nhau mà một hệ điều hành cần phải có. Các chương trình hệ thống, và tất cả các chương trình khác , chạy ở phần trên của kernel (_run on top of the kernel_) . Không gian mà các chương trình đó chạy đuợc gọi là _User mode_. Sự khác biệt giữa các chương trình hệ thống và các chương trình ứng dụng là ở mục tiêu mà chúng đuợc tạo ra. Các chương trình ứng dụng đuợc tạo ra để hỗ trợ hoàn thành các tác vụ người dùng như đã nói ở trên , trong khi nếu hệ thống muốn hoạt động , chúng cần phải có những chương trình hệ thống (**System programs**). Một bộ xử lý chữ cái là một chương trình ứng dụng ; **mount** là một chương trình hệ thống. Sự khác biệt giữa hai loại này đôi khi không rõ ràng, nhưng cũng khá quan trọng khi bạn phân loại các chương trình. Một hệ điều hành cũng thường bao gồm các trình biên dịch (_ví dụ : GCC và các thư viện C trong Linux_) , mặc dù không phải ngôn ngữ lập trình nào cũng cần thiết là một phần của hệ điều hành. Các **documentation**, và đôi khi là cả game, cũng có thể là một phần của hệ điều hành. Một cách truyền thống, một hệ điều hành thường đuợc nhận dạng bởi nội dung của băng hoặc đĩa cài đặt nó (ví dụ Windows sẽ có một đĩa cài Windows đi kèm) , nhưng với Linux , sự nhận dạng này trở nên không rõ ràng từ khi nó bắt đầu đuợc lan truyền ở khắp các trang FTP trên thế giới , người ta dùng nó để tạo nên các biến thể khác nhau với các tên gọi khác nhau.

### 1.2. Các phần quan trọng của Kernel

Hat nhân Linux thường bao gồm một vài phần quan trọng : Đơn vị quản lý tiến trình , đơn vị quản lý bộ nhớ, các drivers phần cứng , drivers fileSystem , đơn vị quản lý mạng và một vài các phần nho nhỏ khác nữa. Bạn có thể tham khảo trong hình dưới đây.

![alt](https://raw.githubusercontent.com/TheEEs/linux-admin/master/images/1.1.png)

Chắc hẳn phần quan trọng nhất của kernel (không có thứ gì khác hoạt động đuợc nếu thiếu chúng) là _đơn vị quản lý bộ nhớ_ và _quản lý tiến trình_ (_memory management and process management_). **Đơn vị quản lý bộ nhớ** sẽ lo việc gán hoặc tráo đổi(_swap_) các vùng bộ nhớ tới các tiến trình , các phần của hạt nhân và **buffer cache**(_một bộ nhớ chứa các dữ liệu chuẩn bị đuợc ghi vào/đã đựợc đọc ra từ ổ đĩa_) . **Đơn vị quản lý tiến trình** tạo ra các tiến trình, và tiến hành hoạt động giả lập đa nhiệm (_multi-tasking_) bằng cách thay phiên hoạt động giữa các processes trên một vi xử lý. Ở tầng thấp nhất, kernel bao gồm các driver phần cứng cho các loại phần cứng mà nó hỗ trợ. Vì trên thế giới hiện tại có rất nhiều các kiểu phần cứng khác nhau, nên đương nhiên số các driver cho các phần cứng khác nhau là khá lớn. Có nhiều những phần cứng tương đương nhau về chức năng nhưng chỉ khác nhau ở cách mà chúng đuợc điều khiển bởi phần mềm. Sự tương đương ấy giúp chúng ta tạo ra những lớp chứa các driver, mà những driver trong lớp ấy thực hiện các chức năng tương tự nhau. Mỗi thành viên của một lớp sẽ có một _giao diện lập trình_ giống với những thành viên còn lại nhưng khác nhau ở những thứ mà nó sẽ làm để hoàn thành công việc của mình. Ví dụ , mỗi **disk driver** đều trông giống như những disk driver còn lại, chúng đều có những giao diện lập trình đại diện cho các hoạt động như "khởi tạo drive" , "đọc sector N" , "ghi sector N" nhưng cách mà mỗi **disk driver** khởi tạo driver , đọc ghi các sector là khác nhau. Một số các dịch vụ đuợc cung cấp bởi kernel tự nó đã có các thuộc tính tương tự nhau, và do đó chúng có thể đuợc trừu tượng hóa vào một giao diện lập trình cụ thể. Ví dụ , các giao thức mạng khác nhau đuợc trừu tượng hóa vào một giao diện lập trình duy nhất - Thư viện BSD socket. Một ví dụ khác chính là _hệ thống tệp tin ảo_ - virtual file system - VFS. Mỗi một loại hệ thống tệp tin khác nhau sẽ cung cấp các thao tác để thao tác trên hệ thống tệp tin đó. Khi một vài thực thể cố gắng sử dụng một filesystem nào đó, các yêu cầu thao tác với filesystem đó sẽ đuợc chuyển đến VFS, VFS sau đó sẽ điều hướng (_routes_) các yêu cầu đó đến một filesystem driver thích hợp.

## 1.3. Các dịch vụ chính trong một hệ thống UNIX và UNIX-like.

Phần này sẽ mô tả một vài các **UNIX services** quan trọng hơn, nhưng không chi tiết. Chúng sẽ đuợc mô tả chi tiết hơn trong các bài viết sau.

#### 1.3.1. init

Dịch vụ đơn quan trọng nhất trong UNIX là **init**. **init** đuợc coi như tiến trình đầu tiên đuợc khởi chạy của mọi hệ thống Unix, và là thứ cuối cùng kernel gọi lên sau khi nó khởi động. Khi **init** bắt đầu, nó tiếp tục quá trình khởi động bằng cách làm một vài công việc khác nhau như kiểm tra và mount các filesystem, khởi động các daemon , v.. v..... Danh sách chính xác những thứ mà **init** phải làm phụ thuộc vào _mode_ của nó là gì ? Và có rất nhiều mode để chọn. **init** cung cấp một loạt định nghĩa về các **chế độ** (_mode_) . Trong đó có _single user mode_ (_chế độ đơn người dùng_), tại đó không một ai có thể log-in và sử dụng shell như một root (_mode này dùng cho các hoạt động quản trị đặc biệt_) , và _multiuser mode - chế độ đa người dùng_ (_dùng cho các hoạt động sử dụng thông thường_). **init** khái quát các mode này bằng một định nghĩa gọi là **cấp độ chạy**-_run level_ . Ở mỗi cấp độ sẽ giới hạn các thao tác mà người dùng có thể tiến hành. _Single và Multi-user mode_ đuợc coi như 2 **run level**, cũng có thể có một vài các **run level** bổ sung, giả sử như một _run level_ cho phép chạy X trên console. Linux cho phép tới 10 _run level_, 0-9 , nhưng thông thường chỉ một vài trong số chúng đuợc định nghĩa mặc định. _Run level 0_ đuợc định nghĩa như là **system halt** (_trạng thái nghỉ của hệ thống_). _Run level 1_ là _single user mode_. _Run level 3_ đuợc định nghĩa là _multi user mode_ .. _Run level 5_ thông thường giống như _Run level 3_ ngoại trừ việc các giao diện đồ họa cũng đuợc bắt đầu. _Run level 6_ là **System reboot**. Các runlevel còn lại phụ thuộc vào bản phân phối Linux của bạn định nghĩa chúng như thế nào. Các runlevel chúng cũng có thể khác nhau trên mỗi một bản phân phối khác nhau. Nhìn vào _/etc/inittab_ bạn sẽ thấy đuợc một vài gợi ý về các runlevel được định nghĩa trước và chức năng của chúng. Trong các hoạt động bình thường, **init** đảm bảo **getty** sẽ hoạt động để cho phép người dùng login , **init** cũng **"nhận nuôi"** các tiến trình **mồ côi** (là các tiến trình mà parent của chúng đã die ; trong UNIX , các tiến trình phải nằm trong một cây duy nhất , nên những tiến trình mồ côi phải đuợc nhận nuôi) Khi hệ thống tắt, vai trò của **init** lúc này là giết tất cả các process khác, unmounting mọi filesystem và dừng vi xử lý, và các công việc khác mà **init** đuợc cấu hình để làm.

#### 1.3.2. Đăng nhập từ terminal.

Việc đăng nhập từ các X terminal hoặc console (nếu bạn chưa chạy X) đuợc cung cấp bởi chương trình **getty**. **init** khởi chạy các instance riêng biệt của **getty** cho mỗi terminal mà ở đó logins đuợc cho phép. **getty** đọc thông tin về _username_ và chạy chương trình **login**- thứ sẽ đọc password mà bạn nhập vào. Nếu thông tin đăng nhập chính xác , **login** sẽ chạy shell.Khi shell chấm dứt , ví dụ người dùng đăng xuất, hoặc khi **login** bị chấm dứt bởi thông tin đăng nhập không chính xác, **init** sẽ nhận ra và khởi chạy một instance mới của **getty**. Kernel không đảm nhận hay lưu tâm đến việc đăng nhập, mọi thứ đuợc làm bởi các **chuơng trình hệ thống**

#### 1.3.3. Syslog

Bản thân Kernel và các chương trình hệ thống sản sinh ra lỗi, cảnh báo và các loại thông điệp khác. Việc xem lại các thông điệp này thường khá quan trọng, nên các thông điệp sẽ đuợc viết vào một file. Chương trình làm điều này là **syslog**. Nó có thể đuợc cấu hình để sắp xếp các thông điệp vào các file khác nhau dựa trên các tiêu chí khác nhau, như loại thông điệp hay mức độ quan trọng. Ví dụ : các thông điệp hệ thống thường đuợc điều hướng đến một file riêng biệt với các file khác, bởi vì các thông điệp hệ thống thường rất quan trọng và cần phải đuợc đọc và phân loại một cách rõ ràng để có thể giải quyết đuợc vấn đề.

#### 1.3.4. Thực thi lệnh theo chu kỳ : cron và at

Cả người dùng và người quản trị hệ thống thường phải chạy một vài lệnh nào đó mỗi lần trong mỗi một khoảng thời gian nhất định , đuợc gọi là chu kỳ. Ví dụ : người quản trị hệ thống có thể muốn chạy một lệnh để xóa các file tạm thời cũ khỏi **các thư mục chứa các file tạm thời** - _temporary files_ (_/tmp_ hoặc _/var/tmp_) để tránh đầy đĩa, bởi vì không phải tất cả các chương trình sau khi chạy đều tự động làm sạch những thứ mà nó tạo ra. Dịch vụ **cron** đuợc thiết đặt để giải quyết vấn đề đó. Mỗi một người dùng có thể có một tệp tên là _crontab_ , ở đó người dùng ấy sẽ liệt kê các command mà anh/cô ấy muốn thực hiện và thời gian mà câu lệnh ấy đuợc thực thi. Daemon của dịch vụ **cron** sẽ có trách nhiệm để tâm đến việc thực thi các lệnh ở mỗi thời điểm đuợc người dùng chỉ rõ. Dịch vụ **at** cũng tương tự với dịch vụ **cron** , nhưng khác duy nhất một điều : _Câu lệnh cũng sẽ đuợc thực thi tại một thời điểm đuợc chỉ rõ, nhưng không đuợc lặp lại_. Chúng ta sẽ nói kỹ hơn về hai dịch vụ này trong các section sau.

#### 1.3.5. GUI - Graphical User Interface - Giao diện người dùng đồ họa

UNIX và Linux không bao gồm các giao diện người dùng vào trong nhân của chúng. Nhưng thay vì thế, chúng cho phép các GUI đuợc triển khai bởi các chương trình người dùng. Điều này đuợc áp dụng cho cả **text mode(terminal/console)** và môi trường đồ họa. Sự sắp đặt này khiến cho hệ thống linh động hơn. Bạn muốn mỗi chương trình triển khai một cơ chế giao diện người dùng khác nhau ? Đơn giản thôi ! Nhưng chính điều này cũng tạo ra một bất cập cho hệ thống, nó khá khó khăn trong việc đồng thời quản lý và tìm hiểu về một loạt các cơ chế UI chạy trên nó. Môi trường đồ họa chủ yếu đuợc dùng trên Linux đuợc gọi là _X Window System_ , gọi tắt là _X_. _X_ không cung cấp bất kỳ một bộ giao diện người dùng nào, nó chỉ triển khai một **hệ thống cửa sổ** - **window system**- thứ mà sẽ cung cấp những API , các daemon cần thiết để bạn có thể xây dựng các _môi trường màn hình nền(DE)_ của riêng mình hoặc implement các DE có sẵn khác. Những tính năng X cung cấp bao gồm đọc input từ bàn phím, chuột, hoặc vẽ những cửa sổ bitmap ra màn hình v..v.... Ngoài ra còn có các bộ quản lý cửa sổ như _fvwm_, _icewm_, _blackbox_ và _windowmaker_. Cũng có những trình quản lý desktop phổ biến cho bạn lựa chọn như **KDE** hoặc **GNOME**.

> Một bộ quản lý cửa sổ là một trình khách (_client_) của X, có chức năng điều hành vị trí hoặc bố cục của các cửa sổ, bao gồm đặt tiêu đề , chồng chéo các cửa sổ lên nhau , thay đổi kích thước, thêm vào các chức năng như các nút **Menu**,**Maximum**, **Minimum** hoặc **Close** , trang trí thanh tiêu đề và focus một cửa sổ khi người dùng click lên nó chẳng hạn. Khi người dùng đề cập tới những môi trường màn hình nền, ý của họ thường là một bộ quản lý cửa sổ đi kèm với những ứng dụng cơ sở kiểu như thanh tác vụ (_task bar_) , trình khởi động ứng dụng (_app launch menu_) , bảng cài đặt hệ thống (_system configuration panel_) , các trình edit text và một vài tiện ích khác. Nên ta nói rằng Window manager là một phần con của Desktop environment.

#### 1.3.6 - Networking - Mạng

Networking là những hành vi kết nối giữa 2 hoặc nhiều máy tính để chúng có thể giao tiếp với nhau. Cách mà các máy tính giao tiếp với nhau khá phức tạp, thế nhưng ứng dụng và hiệu quả mà chúng mang lại thì rất hữu dụng. Hệ điều hành UNIX có rất nhiều các tính năng trong lĩnh vực _networking_. Những dịch vụ cơ bản nhất như _filesystems_, _in ấn_ , _sao lưu_ , v...v... đều có thể đuợc tiến hành qua mạng. Điều này khiến cho người quản trị hệ thống dễ thở hơn, vì nó cho phép sự quản lý tập trung trong khi vẫn áp dụng những lợi ích của _microcomputing- vi tính toán_ hoặc _distributed computing - điện toán phân phối_ như : giá thành rẻ và ít bị các lỗi cục bộ làm ảnh hưởng đến toàn hệ thống.

#### 1.3.7. Đăng nhập từ mạng

**Đăng nhập từ mạng** khác một chút so với đăng nhập bình thường. Mỗi một người đăng nhập vào hệ thống sẽ có một _kết nối ảo riêng biệt_ - _separate virtual network connection_, số lượng các kết nối ảo này có thể là bất kỳ phụ thuộc vào băng thông có sẵn. Mỗi một kết nối ảo sẽ không sử dụng một instance của chương trình **getty** cho mục đích đăng nhập. Có nhiều cách khác để đăng nhập từ mạng, ví dụ **telnet** hoặc **ssh** ngày nay đuợc xem như những phương pháp chính để đăng nhập trên một mạng TCP/IP. Ngày nay nhiều người quản trị hệ thống Linux đều cho rằng **telnet** hoặc **rlogin** không bảo mật. Họ có thiên hướng chuyển sang sử dụng **ssh - secure shell** - thứ mà sẽ **mật mã hóa** mọi traffic của bạn trên mạng. Như vậy sẽ khiến cho các phần mềm gián điệp không thể nghe lén các gói tin đuợc gửi đi , và không thể capture đuợc những thông tin nhạy cảm như _user name_ hoặc _password_ của bạn. Tôi cũng nâng cao quan điểm về việc khuyên bạn dùng **ssh** thay vì các dịch vụ network logins khác.

**Đăng nhập từ mạng** - thay vì gọi một bầy những instance của **getty** để phục vụ cho mỗi một _separate virtual connection_ thì một daemon duy nhất cho một cách đăng nhập (**ssh** và **telnet** sẽ có hai daemon riêng biệt) sẽ lắng nghe tất cả các cố gắng đăng nhập từ bên ngoài. Khi nó nhận ra một nhu cầu đăng nhập , nó sẽ khởi chạy một instance riêng của chính nó để xử lý nhu cầu đăng nhập đó, còn nó thì vẫn tiếp tục lắng nghe các cố gắng truy cập khác. Instance đuợc khởi chạy sẽ hoạt động tương tự **getty**.

#### 1.3.8 - Hệ thống tệp tin mạng - Network FileSystem

Một trong những thứ hữu dụng nhất có thể đuợc triển khai qua dịch vụ mạng chính là chia sẻ tệp tin(_files sharing_) qua một **hệ thống tệp tin mạng**. Tùy thuộc vào mạng của bạn mà nhu cầu chia sẻ file có thể được triển khai bằng **Network File System**(NFS) hoặc **Common Internet File System**(CIFS). **NFS** thông thường là một dịch vụ UNIX , trong Linux , **NFS** đuợc hỗ trợ bởi kernel. Tuy nhiên CIFS thì không , nó đuợc hỗ trợ bởi [Samba](http://www.samba.org). Với sự hỗ trợ của các hệ thống tệp tin mạng, mọi thao tác với các tệp tin của một chương trình trên một máy sẽ đuợc gửi tới một máy khác qua mạng. Thủ thuật này lừa đảo các chương trình , làm cho chương trình nghĩ rằng mọi file ở máy khác đều thực sự nằm trên máy mà nó đang chạy. Trò lừa đảo này rất hữu dụng vì nó khiến cho nhu cầu chia sẻ trở nên cực kỳ đơn giản mà không cần tiến hành bất kỳ một sự thay đổi nào trên chương trình.

#### 1.3.9 - Mail

Thư điện tử là một trong những phương pháp phổ biến nhất để giao tiếp qua mạng từ một máy tính. Một thư điện tử đuợc lưu trữ trong một file sử dụng một định dạng đặc biệt. Một chương trình mail đặc biệt đuợc sử dụng để đọc và gửi các thư điện tử. Mỗi người dùng đều có một **hộp thư đến** - _incoming mailbox_ hay _inbox_ - là một file thuộc một định dạng đặc biệt , ở đó sẽ lưu trữ các mail mới. Khi ai đó gửi mail, chương trình mail sẽ định vị hộp thư của người nhận và ghi mail vào cuối(append) file mailbox của người đó.Nếu người nhận ở trên một máy khác , thì mail sẽ đuợc gửi qua máy đó, và đuợc thêm vào các mailbox phù hợp. Hệ thống thư điện tử bao gồm rất nhiều các chương trình. Sự phân phát mail tới các hộp thư cục bộ hoặc từ xa chỉ đuợc tiến hành bởi một chương trình quản lý gửi mail (_mail transfer agent - MTA_) như **sendmail** hoặc **postfix** trong chi các chuơng trình cho nguời dùng(_mail user agent -MUA_) thì rất đa dạng và phong phú , ví dụ **pine** hoặc **evolution**. Các hộp thư thường đuợc lưu trữ tại _/var/spool/mail_ cho đến khi **MUA** thu thập chúng.

#### 1.3.10 - In ấn

Máy in đuợc sử dụng bởi một người trong một lần, nhưng như vậy khá **thiếu tính kinh tế** khi chia sẻ máy in giữa nhiều người. Vì vậy máy in đuợc quản lý bởi một chương trình, chương trình này sẽ triển khai một hàng đợi (_print queue_) : tất cả các tác vụ in ấn đuợc đưa vào trong hàng đợi và mỗi khi một tác vụ đuợc hoàn thành, tác vụ tiếp theo sẽ đuợc triển khai một cách tự động. Điều này làm cho người dùng không phải lo nghĩ về khâu tổ chức sử dụng máy hoặc phải đánh nhau để giành quyền kiểm soát máy in. Thay vào đó họ sẽ xếp hàng và đợi đến khi bản in của mình đuợc in ra . Không một ai biết bản in của mình và người khác sẽ đuợc in xong khi nào , rất có khả năng họ sẽ bắt chuyện với nhau trong khi chờ đợi để giết thời gian. Đây là một lợi thế lớn cho các mối quan hệ xã hội trong nội bộ các văn phòng. **Print queue** cũng tiến hành xử lý các bản in trên đĩa theo style _cuốn chiếu_ . Ví dụ : nội dung của một bản in nào đó (text , image) sẽ đuợc lưu trong một file, trong khi lượt in của bản in đó đuợc xếp trong hàng đợi của phần mềm. Điều này cho phép các phần mềm ứng dụng , đưa các yêu cầu in ấn của nó vào hàng đợi hoặc sửa nội dung bản in một cách dễ dàng và nhanh chóng , ứng dụng không cần phải chờ đến khi bản in trước thực sự đuợc in xong mới tiếp tục. Như vậy rất tiện lợi, nó cho phép một yêu cầu in chỉ in ra một phiên bản của bản in nhưng bạn có thể chỉnh sửa bản in ngay cả khi yêu cầu in ấn đã đuợc push vào trong hàng đợi mà không cần chờ để in một phiên bản khác.

#### 1.3.11 - Bố cục của hệ thống tệp tin

Hệ thống tệp tin đuợc chia nhỏ thành nhiều phần , thường ở sau một đường thẳng **/** tượng trưng cho _root filesystem_. Ví dụ _/bin_ , _/lib_ ,_/etc_ , _/dev_ , và một vài thứ khác. **/usr** filesystem chứa các chương trình và những dữ liệu bất biến. **/var** thì chứa các dữ liệu khả biến (_changable data_) như các log file. Và **/home** chứa các dữ liệu cá nhân của mọi người. Tùy thuộc vào cấu hình phần cứng và quyết định của người quản trị hệ thống , sự chia nhỏ hệ thống tệp tin có thể khác đi. Thậm chí có khi nó còn bao gồm tất cả trong một filesystem duy nhất.

> Chương 2 tổng quan về cây thư mục. Các bạn đón đọc ở [Đây](https://kipalog.com/posts/Series----Linux-System-Administrator-s-guide---Phan-2) nhé.

Trần Bá Đạt - 22/10/2016. Nguồn : [The Linux documentation project](http://tldp.org)
